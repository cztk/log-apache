
# Kibana ML required fields
# "data_stream.dataset": "apache.access"
# "source.address"
# "url.original"
# "http.response.status_code"

input {
  beats {
    port => 1044
#     codec => plain {
#       charset => "ISO-8859-1"
#     }
  }
}

filter {

  if "apache_security" in [tags] {
      # http.request.body.content
      # TODO
      # thinking of seperate log processing and
      # use elastic enrichment
      # get data as update from script
      #
      # The full HTTP request body.
      # type: wildcard
      # Multi-fields:
      #  http.request.body.content.text (type: match_only_text)
      # level: extended
      # example: Hello world
      # apache: mod_security
      # SecRequestBodyAccess On
      # SecAuditLogParts > C Request body

      # http.request.mime_type
      # TODO
      # thinking of seperate log processing and
      # use elastic enrichment
      # get data as update from script
      #
      # Mime type of the body of the request.
      # This value must only be populated based on the content of the request body,
      # not on the Content-Type header.
      # type: keyword
      # example: image/gif
      # level: extended

      # http.response.body.content
      # TODO
      #
      # The full HTTP response body.
      # type: wildcard
      # Multi-fields:
      #  http.response.body.content.text (type: match_only_text)
      # level: extended
      # example: Hello World

      # http.response.mime_type
      # TODO
      #
      # Mime type of the body of the response.
      # This value must only be populated based on the content of the response body, not on the Content-Type header.
      # type: keyword
      # level: extended
      # example: image/gif


  }





  if "apache_access" in [tags] {

    # LogFormat common
    # LogFormat "%h %l %u %t \"%r\" %>s %b" common
    # LogFormat combined
    # LogFormat "%h %l %u %t \"%r\" %>s %b \"%{Referer}i\" \"%{User-agent}i\"" combined
    # https://httpd.apache.org/docs/2.4/logs.html
    #
    #HTTPD_COMMONLOG %{IPORHOST:[source][address]} (?:-|%{HTTPDUSER:[apache][access][user][identity]}) (?:-|%{HTTPDUSER:[user][name]}) \[%{HTTPDATE:timestamp}\] "(?:%{WORD:[http][request][method]} %{NOTSPACE:[url][original]}(?: HTTP/%{NUMBER:[http][version]})?|%{DATA})" (?:-|%{INT:[http][response][status_code]:int}) (?:-|%{INT:[http][response][body][bytes]:int})
    ## :long - %{INT:[http][response][body][bytes]:int}
    #HTTPD_COMBINEDLOG %{HTTPD_COMMONLOG} "(?:-|%{DATA:[http][request][referrer]})" "(?:-|%{DATA:[user_agent][original]})"
    #
    ## Be aware, %h can return a list of IP ( X-Forwarded-For )
    ## %h Remote hostname. Will log the IP address if HostnameLookups is set to Off, which is the default.
    ## The field is read from left to right, where the first entry _should_ be the client ip
    ## there are multiple possible solutions
    ## trusting this header and use the first ip in general is a bad idea, be careful
    ## %a      Client IP address of the request (see the mod_remoteip module).
    ## %{c}a   Underlying peer IP address of the connection (see the mod_remoteip module).
    ##


    grok {
      match => {
        "message" => ""
      }
      add_tag => ["parsed"]
      remove_field => ["message"]
    }

    ## Data Stream Fields

    mutate {
      add_field => { "[data_stream][dataset]" => "apache.access" }
      add_field => { "[data_stream][namespace]" => "production" }
      add_field => { "[data_stream][type]" => "logs" }
      # add_field => { "[ecs][version]" => "8.11" }
    }

    ## Base Fields

    # @timestamp
    # Date/time when the event originated.
    # This is the date/time extracted from the event, typically representing when the event was generated by the source.
    # If the event source has no original timestamp,
    # this value is typically populated by the first time the event was received by the pipeline.
    # type: date
    # level: core
    # required: true
    # example: 2016-05-23T08:05:34.853Z
    # apache: %t
    date {
      match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
      target => "@timestamp"
    }

    # labels
    # Custom key/value pairs.
    # Can be used to add meta information to events. Should not contain nested objects. All values are stored as keyword.
    # example: docker
    # example: {"application": "foo-bar", "env": "production"}
    # type: object
    # level: core

    # message
    # For log events the message field contains the log message, optimized for viewing in a log viewer.
    # For structured logs without an original message field, other fields can be concatenated to form a human-readable summary of the event.
    # If multiple messages exist, they can be combined into one message.
    # type: match_only_text
    # level: core
    # example: Hello World

    # tags
    # List of keywords used to tag each event.
    # type: keyword
    # Note: this field should contain an array of values.
    # example: ["production", "env2"]
    # level: core

    ## Agent fields
    ## Agents may also run on observers. ECS agent.* fields shall be populated with details
    ## of the agent running on the host or observer where the event happened or the measurement was taken.

    ## Client Fields
    ## A client is defined as the initiator of a network connection for events regarding sessions,
    ## connections, or bidirectional flow records.

    # client.address
    # Some event client addresses are defined ambiguously.
    # The event will sometimes list an IP, a domain or a unix socket.
    # You should always store the raw address in the .address field.
    # Then it should be duplicated to .ip or .domain, depending on which one it is.
    # type: keyword
    # level: extended
    # apache: %a
    if [clientip] {
      mutate {
        copy => { "clientip" => "[client][address]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_client_address]" => true }
      }
    }

    # client.bytes
    # Bytes sent from the client to the server.
    # type: long
    # example: 184
    # level: core
    # apache: %I
    #  	Bytes received, including request and headers. Cannot be zero
    if [client_bytes] {
      mutate {
        rename => { "client_bytes" => "[client][bytes]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_client_bytes]" => true }
      }
    }

    # client.domain
    # TODO
    #
    # The domain name of the client system.
    # This value may be a host name, a fully qualified domain name, or another host naming format.
    # The value may derive from the original event or be added from enrichment.
    # type: keyword
    # level: core
    # example: foo.example.com

    # client.ip
    # IP address of the client (IPv4 or IPv6).
    # type: ip
    # level: core
    # apache: %a
    if [clientip] {
      mutate {
        rename => { "clientip" => "[client][ip]" }
      }
    } else {
      mutate {
        add_field => { "[@metadata][missing_client_ip]" => true }
      }
    }

    # client.mac
    # TODO - decide worthy for rare cases
    # for same lan

    # client.nat.ip
    # TODO - decide
    #
    # Translated IP of source based NAT sessions (e.g. internal client to internet).
    # Typically connections traversing load balancers, firewalls, or routers.

    # client.nat.port
    # TODO - decide

    # client.packets
    # TODO - enrichment from firewall?
    #
    # Packets sent from the client to the server.
    # type: long
    # example: 12
    # level: core

    # client.port
    # Port of the client.
    # type: long
    # level: core
    # apache: %{remote}p
    if [client_port] {
      mutate {
        rename => { "client_port" => "[client][port]" }
      }
    } else {
      mutate {
        add_field => { "[@metadata][missing_client_port]" => true }
      }
    }

    # client.registered_domain
    # TODO - decide

    # client.subdomain
    # TODO - decide

    # client.top_level_domain
    # TODO - decide

    # client.as
    # client.geo
    # is currently done by
    # apache enrichment pipeline
    #
    # hardware of logstash / elastic
    # usage of elastic low?


    ## Device Fields
    if [user_agent] {
      useragent {
        source => "user_agent"
      }
    } else {
      mutate {
        add_field => { "[@metadata][missing_user_agent]" => true }
      }
    }



    ## HTTP fields

    # to get the correct http_version and request_method
    # we need to parse apache %r log entry which is the first
    # line of a request
    # if that fails, we check might be lucky getting apache %m
    # save in: request_method
    # apache: %m > not sure if it retains casing
    # %r can be used and split. if it is not missing due to reasons
    if [pp_request_first_line] and [pp_request_first_line] != "-" {
      grok {
        match => {
          "http_request" => "%{WORD:pp_r_request_method} %{URIPATHPARAM:request_uri} HTTP/%{NUMBER:http_version}"
        }
        add_tag => ["http_pp_request_first_line"]
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_request_first_line]" => true }
       add_tag => ["invalid_http_request"]
      }
    }
    if [pp_r_request_method] {
      mutate {
        rename => { "pp_r_request_method" => "request_method" }
      }
    } else {
      if [pp_m_request_method] {
        if [pp_m_request_method] == "" or [pp_m_request_method] == "-" {
          mutate {
            rename => { "pp_m_request_method" => "request_method" }
          }
      }
    }

    # http.request.body.bytes
    # Size in bytes of the request body.
    # type: long
    # level: extended
    # example: 887
    # apache: %{Content-Length}i
    if [request_body_bytes] {
      mutate {
        convert => { "request_body_bytes" => "integer" }
        rename => { "request_body_bytes" => "[http][request][body][bytes]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_request_body_bytes]" => true }
      }
    }

    # http.request.body.content
    # see apache_security log

    # http.request.bytes
    # Total size in bytes of the request (body and headers).
    # type: long
    # level: extended
    # example: 1437
    # apache: %S
    if [request_bytes] {
      mutate {
        convert => { "request_bytes" => "integer" }
        rename => { "request_bytes" => "[http][request][bytes]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_request_bytes]" => true }
      }
    }

    # http.request.id
    # A unique identifier for each HTTP request to correlate logs between clients and servers in transactions.
    # The id may be contained in a non-standard HTTP header, such as X-Request-ID or X-Correlation-ID.
    # type: keyword
    # level: extended
    # example: 123e4567-e89b-12d3-a456-426614174000
    # apache: %{UNIQUE_ID}e
    # requires mod unique_id
    if [request_id] {
      mutate {
        rename => { "request_id" => "[http][request][id]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_request_id]" => true }
      }
    }

    # http.request.method
    # The value should retain its casing from the original event.
    # For example, GET, get, and GeT are all considered valid values for this field.
    # type: keyword
    # level: extended
    # example: POST
    # apache: %m > not sure if it retains casing
    # %r can be used and split. if it is not missing due to reasons
    if [request_method] {
      mutate {
        rename => { "request_method" => "[http][request][method]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_request_method]" => true }
      }
    }

    # http.request.mime_type
    # see apache_security log

    # http.request.referrer
    # Referrer for this HTTP request.
    # type: keyword
    # level: extended
    # example: https://blog.example.com/
    # apache: %{Referer}i
    if [request_referrer] {
      mutate {
        rename => { "request_referrer" => "[http][request][referrer]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_request_referrer]" => true }
      }
    }

    # http.response.body.bytes
    # Size in bytes of the response body.
    # type: long
    # level: extended
    # example: 887
    # apache: %B
    if [response_body_bytes] {
      mutate {
        convert => { "response_body_bytes" => "integer" }
        rename => { "response_body_bytes" => "[http][response][body][bytes]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_response_body_bytes]" => true }
      }
    }

    # http.response.body.content
    # see apache_security log

    # http.response.bytes
    # Total size in bytes of the response (body and headers).
    # type: long
    # level: extended
    # example: 1437
    # apache: %O
    # Bytes sent, including headers.
    # May be zero in rare cases such as when a request is aborted before a response is sent.
    if [response_bytes] {
      mutate {
        convert => { "response_bytes" => "integer" }
        rename => { "response_bytes" => "[http][response][bytes]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_response_bytes]" => true }
      }
    }

    # http.response.mime_type
    # see apache_security log

    # http.response.status_code
    # HTTP response status code.
    # type: long
    # level: extended
    # example: 404
    # apache: %>s
    if [response_status_code] {
      mutate {
        convert => { "response_status_code" => "integer" }
        rename => { "response_status_code" => "[http][response][status][code]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_response_status_code]" => true }
      }
    }

    # http.version
    # HTTP version.
    # type: keyword
    # level: extended
    # example: 1.1
    # apache: %r
    if [http_version] {
      mutate {
        rename => { "http_version" => "[http][version]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_http_version]" => true }
      }
    }


    ## TLS fields

    # let us save some time and space
    # if we do not handle tls connection
    # apache: %{SSL_PROTOCOL}x
    if [SSL_PROTOCOL] {


        # tls.cipher
        # String indicating the cipher used during the current connection.
        # type: keyword
        # level: extended
        # example: TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256
        # apache: %{SSL_CIPHER}x
        if [tls_cipher] {
          mutate {
            rename => { "tls_cipher" => "[tls][cipher]" }
          }
        }

        # tls.client.certificate
        # tls.client.certificate_chain
        # tls.client.hash.md5
        # ...

        # tls.client.issuer
        # Distinguished name of subject of the issuer of the x.509 certificate presented by the client.
        # type: keyword
        # level: extended
        # example: CN=Example Root CA, OU=Infrastructure Team, DC=example, DC=com
        # apache: %{SSL_CLIENT_I_DN_CN}x
        if [SSL_CLIENT_I_DN_CN] {
          mutate {
            rename => { "SSL_CLIENT_I_DN_CN" => "[tls][client][issuer]" }
          }
        }

        # tls.client.not_after
        # Date/Time indicating when client certificate is no longer considered valid.
        # type: date
        # level: extended
        # example: 2021-01-01T00:00:00.000Z
        # apache: %{SSL_CLIENT_V_END}x
        if [SSL_CLIENT_V_END] {
          date {
            match => [ "SSL_CLIENT_V_END", "yyyy-MM-dd'T'HH:mm:ssZ" ]
            target => "[tls][client][not_after]"
          }
        }

        # tls.client.not_before
        # Date/Time indicating when client certificate is first considered valid.
        # type: date
        # level: extended
        # example: 2021-01-01T00:00:00.000Z
        # apache: %{SSL_CLIENT_V_START}x
        if [SSL_CLIENT_V_START] {
          date {
            match => [ "SSL_CLIENT_V_START", "yyyy-MM-dd'T'HH:mm:ssZ" ]
            target => "[tls][client][not_before]"
          }
        }

        # tls.client.server_name
        # Also called an SNI, this tells the server which hostname to which the client is attempting to connect to.
        # When this value is available, it should get copied to destination.domain.
        # type: keyword
        # example: www.ztk.me
        # level: extended
        # apache: %{SSL_TLS_SNI}x
        if [SSL_TLS_SNI] {
          mutate {
            rename => { "SSL_TLS_SNI" => "[tls][client][server_name]" }
            copy => { "[tls][client][server_name]" => "[destination][domain]" }
          }
        }

        # tls.client.subject
        # Distinguished name of subject of the x.509 certificate presented by the client.
        # type: keyword
        # example: CN=myclient, OU=Documentation Team, DC=example, DC=com
        # level: extended
        # apache: %{SSL_CLIENT_S_DN}x
        if [SSL_CLIENT_S_DN] {
          mutate {
            rename => { "SSL_CLIENT_S_DN" => "[tls][client][subject]" }
          }
        }

        # tls.established
        # Boolean flag indicating if the TLS negotiation was successful and transitioned to an encrypted tunnel.
        # type: boolean
        # level: extended
        # Note: we assume true if we are in this branch
        # apache: %{SSL_PROTOCOL}x
        mutate {
          add_field => { "[tls][established]" => true }
        }

        # tls.next_protocol
        # String indicating the protocol being tunneled. Per the values in the IANA registry
        # (https://www.iana.org/assignments/tls-extensiontype-values/tls-extensiontype-values.xhtml#alpn-protocol-ids),
        # this string should be lower case.
        # type: keyword
        # level: extended
        # example: http/1.1
        # apache: requires http2
        # %{HTTP2_PROTOCOL}x
        # This variable will log the negotiated protocol (e.g., h2 for HTTP/2).
        if [HTTP2_PROTOCOL] {
          mutate {
            rename => { "HTTP2_PROTOCOL" => "[tls][next_protocol]" }
            lowercase => [ "[tls][next_protocol]" ]
          }
        }

        # tls.resumed
        # Boolean flag indicating if this TLS connection was resumed from an existing TLS negotiation.
        # type: boolean
        # level: extended
        # apache: %{SSL_SESSION_RESUMED}x
        # Resumed | Initial
        if [SSL_SESSION_RESUMED] == "Resumed" {
          mutate {
            add_field => { "[tls][resumed]" => true }
            remove_field => ["SSL_SESSION_RESUMED"]
          }
        } else {
          mutate {
            add_field => { "[tls][resumed]" => false }
          }
        }

        # tls.server.issuer
        # Distinguished name of subject of the issuer of the x.509 certificate presented by the server.
        # type: keyword
        # level: extended
        # example: CN=Example Root CA, OU=Infrastructure Team, DC=example, DC=com
        # apache: %{SSL_SERVER_I_DN_CN}x
        if [SSL_SERVER_I_DN_CN] {
          mutate {
            rename => { "SSL_SERVER_I_DN_CN" => "[tls][server][issuer]" }
          }
        }

        # tls.server.not_after
        # Date/Time indicating when server certificate is no longer considered valid.
        # type: date
        # level: extended
        # example: 2021-01-01T00:00:00.000Z
        # apache: %{SSL_SERVER_V_END}x
        if [SSL_SERVER_V_END] {
          date {
            match => [ "SSL_SERVER_V_END", "yyyy-MM-dd'T'HH:mm:ssZ" ]
            target => "[tls][server][not_after]"
          }
        }

        # tls.server.not_before
        # Date/Time indicating when server certificate is first considered valid.
        # type: date
        # level: extended
        # example: 2021-01-01T00:00:00.000Z
        # apache: %{SSL_SERVER_V_START}x
        if [SSL_SERVER_V_START] {
          date {
            match => [ "SSL_SERVER_V_START", "yyyy-MM-dd'T'HH:mm:ssZ" ]
            target => "[tls][server][not_before]"
          }
        }

        # tls.server.subject
        # Distinguished name of subject of the x.509 certificate presented by the server.
        # type: keyword
        # example: CN=myclient, OU=Documentation Team, DC=example, DC=com
        # level: extended
        # apache: %{SSL_SERVER_S_DN}x
        if [SSL_SERVER_S_DN] {
          mutate {
            rename => { "SSL_SERVER_S_DN" => "[tls][server][subject]" }
          }
        }

        # tls.version
        # Numeric part of the version parsed from the original string.
        # type: keyword
        # example: 1.2
        # level: extended
        # apache: %{SSL_PROTOCOL}x
        # logs as TLSv1.2, TLSv1.3
        # tls.protocol
        # Normalized lowercase protocol name parsed from original string.
        # type: keyword
        # example: tls
        # level: extended
        # apache: %{SSL_PROTOCOL}x
        if [SSL_PROTOCOL] {
          if [SSL_PROTOCOL] =~ /^TLSv(\d+\.\d+)$/ {
            mutate {
              add_field => { "[tls][version]" => "%{TLSv%{1}}" }
              add_field => { "[tls][protocol]" => "tls" }
              remove_field => [SSL_PROTOCOL]
            }
          }
        }

    }  ## end TLS fields

    ## URL Fields

    # using apache log starting with common/combined grok pattern
    # Extract components of the request field
    dissect {
      mapping => {
        "request" => "%{http_request_method} %{url_original} HTTP/%{http_version}"
      }
    }

    # Decode the URL
    urldecode {
      field => "url_original"
    }

    # Extract domain, path, query, and scheme from the URL
    ruby {
      code => "
        require 'uri'
        begin
          uri = URI.parse(event.get('url_original'))
          event.set('url_domain', uri.host)
          event.set('url_path', uri.path)
          event.set('url_query', uri.query)
          event.set('url_scheme', uri.scheme)
        rescue => e
          event.tag('_uriparsefailure')
          event.set('url_original', nil)
        end
      "
    }

    # url.domain
    # Domain of the url, such as "www.elastic.co".
    # In some cases a URL may refer to an IP and/or port directly, without a domain name.
    # In this case, the IP address would go to the domain field.
    # If the URL contains a literal IPv6 address enclosed by [ and ] (IETF RFC 2732), the [ and ]
    # characters should also be captured in the domain field.
    # type: keyword
    # example: www.ztk.casa
    # level: extended
    # apache: %v
    if [apache_servername] {
      mutate {
        rename => { "apache_servername" => "[url][domain]" }
      }
    } else {
      mutate {
       add_field => { "[@metadata][missing_url_domain]" => true }
      }
    }


 ## following are just some random thoughts for now


  # Extract components of the request field
  dissect {
    mapping => {
      "request" => "%{http.request.method} %{url.original} HTTP/%{http.version}"
    }
  }

  # Parse URL to extract additional components
  urldecode {
    field => "url.original"
  }

  urldecode {
    field => "http.request.referrer"
    target => "url.referrer"
  }

  # Add additional URL fields based on ECS
  mutate {
    rename => {
      "client_ip" => "client.ip"
      "bytes" => "http.response.body.bytes"
      "useragent" => "user_agent.original"
      "referer" => "http.request.referrer"
    }
    add_field => {
      "[url][path]" => "%{[url.original]}"
    }
  }

  # Extract more details from the URL
  urldecode {
    field => "[url][original]"
  }

  kv {
    source => "url.original"
    target => "url"
    field_split => "&?"
    value_split => "="
  }

  # Convert the timestamp to the proper date format
  date {
    match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
    target => "@timestamp"
  }

  useragent {
    source => "user_agent.original"
    target => "user_agent"
  }

  # Clean up fields if necessary (e.g., remove raw fields after parsing)
  mutate {
    remove_field => [ "message", "timestamp", "client.ip", "request", "http.version", "bytes", "useragent", "referer" ]
  }




    if [network_forwarded_ip] == "-" {
      mutate {
        remove_field => ["network_forwarded_ip"]
      }
    }
    if [network_forwarded_ip] != "-" {
      mutate {
        split => { "network_forwarded_ip" => "," }
        rename => {
          "network_forwarded_ip" => "[apache][accessremote][addresses]"
        }
      }
    }



    mutate {
      copy => {
        "[apache][vhost]" => "url_domain"
      }
    }
    if [apache][accessremote][addresses] and [apache][accessremote][addresses][0] == [source][ip] {
      if [apache][accessremote][addresses][1] {
        mutate {
          add_field => { "[network][forwarded_ip]" => "%{[apache][accessremote][addresses]}" }
        }
      }
    }



}

output {



  stdout { codec => rubydebug }
}
